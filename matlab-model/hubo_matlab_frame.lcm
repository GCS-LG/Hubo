package hubo;

//Matlab I/O LCM structs
struct hubo_matlab_frame {
    double NKY;
    double HNP;
    double HNR;
    double LSP;
    double LSR;
    double LSY;
    double LEB;
    double LWY;
    double LWP;
    double leftThumbKnuckle1;
    double leftThumbKnuckle2;
    double leftThumbKnuckle3;
    double leftPinkyKnuckle1;
    double leftPinkyKnuckle2;
    double leftPinkyKnuckle3;
    double leftRingKnuckle1;
    double leftRingKnuckle2;
    double leftRingKnuckle3;
    double leftMiddleKnuckle1;
    double leftMiddleKnuckle2;
    double leftMiddleKnuckle3;
    double leftIndexKnuckle1;
    double leftIndexKnuckle2;
    double leftIndexKnuckle3;
    double RSP;
    double RSR;
    double RSY;
    double REB;
    double RWY;
    double RWP;
    double rightThumbKnuckle1;
	double rightThumbKnuckle2;
    double rightThumbKnuckle3;
	double rightPinkyKnuckle1;
	double rightPinkyKnuckle2;
	double rightPinkyKnuckle3;
	double rightRingKnuckle1;
	double rightRingKnuckle2;
	double rightRingKnuckle3;
	double rightMiddleKnuckle1;
	double rightMiddleKnuckle2;
	double rightMiddleKnuckle3;
	double rightIndexKnuckle1;
	double rightIndexKnuckle2;
	double rightIndexKnuckle3;
	double WST;
	double LHY;
	double LHR;
	double LHP;
	double LKN;
	double LAP;
	double LAR;
	double RHY;
	double RHR;
	double RHP;
	double RKN;
	double RAP;
	double RAR;
	double NKYdot;
	double HNPdot;
	double HNRdot;
	double LSPdot;
	double LSRdot;
	double LSYdot;
	double LEBdot;
	double LWYdot;
	double LWPdot;
	double leftThumbKnuckle1dot;
	double leftThumbKnuckle2dot;
	double leftThumbKnuckle3dot;
	double leftPinkyKnuckle1dot;
	double leftPinkyKnuckle2dot;
	double leftPinkyKnuckle3dot;
	double leftRingKnuckle1dot;
	double leftRingKnuckle2dot;
	double leftRingKnuckle3dot;
	double leftMiddleKnuckle1dot;
	double leftMiddleKnuckle2dot;
	double leftMiddleKnuckle3dot;
	double leftIndexKnuckle1dot;
	double leftIndexKnuckle2dot;
	double leftIndexKnuckle3dot;
	double RSPdot;
	double RSRdot;
	double RSYdot;
	double REBdot;
	double RWYdot;
	double RWPdot;
	double rightThumbKnuckle1dot;
	double rightThumbKnuckle2dot;
	double rightThumbKnuckle3dot;
	double rightPinkyKnuckle1dot;
	double rightPinkyKnuckle2dot;
	double rightPinkyKnuckle3dot;
	double rightRingKnuckle1dot;
	double rightRingKnuckle2dot;
	double rightRingKnuckle3dot;
	double rightMiddleKnuckle1dot;
	double rightMiddleKnuckle2dot;
	double rightMiddleKnuckle3dot;
	double rightIndexKnuckle1dot;
	double rightIndexKnuckle2dot;
	double rightIndexKnuckle3dot;
	double WSTdot;
	double LHYdot;
	double LHRdot;
	double LHPdot;
	double LKNdot;
	double LAPdot;
	double LARdot;
	double RHYdot;
	double RHRdot;
	double RHPdot;
	double RKNdot;
	double RAPdot;
	double RARdotNKY;
}

//DirectACH LCM structs
struct hubo_sensor_param {
	int16_t sensNo;	///< Sensor number
	int16_t can;		///< Can channel
	int16_t boardNo;	///< Sensor Board Nuber
	int8_t active;		///< Active sensor
	string name[5];		///< Name of sensor
        int16_t xsign;
        int16_t ysign;
        int16_t zsign;
}
struct hubo_joint_param {
	int32_t refEnc; 	///< encoder reference
	int16_t motNo;		///< Onboard channel number
	int16_t jntNo;		///< what overall number joint is it i.e. what RSP=23
	int16_t drive;		///< size of drive wheel
	int16_t driven;	///< size of driven wheel
	int16_t harmonic;	///< gear ratio of harmonic drive
	int16_t enc;		///< encoder size
	int16_t jmc;		///< motor controller number
	int16_t dir;		    ///< direction
	int8_t can;		///< can channel
	int8_t numMot;		///< number of motors
	string name[4];		///< name
}
struct hubo_jmc_param {
	int8_t joints[5]; // other motors on the same drive
}
struct hubo_board_joint_param {
    int64_t confidence;

    int16_t deadZone;

    int32_t homeOffsetRaw;
    double homeOffset;
    int8_t searchDirection;
    int8_t searchMode;
    int16_t searchLimit;
//    int16_t searchLimitRaw;
//    double searchLimit;

    int16_t maxHomeAccelRaw;
    double maxHomeAccel;
    int16_t maxHomeLimitVelRaw; ///< Maximum Velocity for Home limit search
    double maxHomeLimitVel;
    int16_t maxHomeOffsetVelRaw; ///< Maximum Velocity to Offset position
    double maxHomeOffsetVel;

    int32_t lowerLimitRaw;
    double lowerLimit;
    int32_t upperLimitRaw;
    double upperLimit;
    int16_t maxAccelRaw;
    double maxAccel;

    int16_t maxVelRaw;
    double maxVel;
    int16_t maxPWM;
    int16_t maxCurrent;
    
    int16_t Kp;
    int16_t Ki;
    int16_t Kd;
    int16_t Kpt; ///< Motor position gain ...t?
    int16_t Kdt; ///< Motor derivative gain ...t?
    int16_t Kft; ///< Motor current gain ...t?

    int16_t encoderResolution;
    int8_t motorDirection;
    int8_t autoScale;
    
    int16_t canRate;
    int8_t boardType;

    int16_t jamTimeRaw;
    double jamTime;
    int16_t pwmSaturationTimeRaw;
    double pwmSaturationTime;
    int8_t pwmDutyLimit;
    int8_t pwmDutyJam;

    int16_t maxInputDifference;
    int16_t maxError;
    int16_t maxEncError; ///< Maximum error for encoder failure

}
struct hubo_imu {
	double a_x;     ///< angular position around x (rad)
	double a_y;     ///< angular position around y (rad)
        double a_z;     ///< angular position around z
	double w_x;     ///< rotational velocity in x (rad/s)
	double w_y;     ///< rotational velocity in y (rad/s)
	double w_z;     ///< rotational velocity in z (rad/s)
}

struct hubo_virtual {
    double time; ///< trigger channel time in (sec)

}
struct hubo_ft {
	double m_x;	///< Moment in X (Mx)
	double m_y;	///< Moment in Y (My)
	double f_z;	///< Force in Z (Fz)
}
struct hubo_joint_state {
        double ref;         ///< Last reference value sent
	int8_t comply;		///< Are we in compliance mode?
                        ///< 0: Rigid mode
                        ///< 1: Compliant mode
                        ///< 2: Transitioning back to rigid
                        ///< 3: Turning motor control back on (should never be seen by the user) 
	double pos;     	///< actual position (rad)
	double cur;     	///< actual current (amps)
	double vel;     	///< actual velocity (rad/sec)
        double duty;            ///< PWM duty cycle
	double heat;		///< Heat generated by motor in Joules >> NOTE: THIS IS NOT TEMPERATURE
        double tmp;
	int8_t active; 	///< checks if the joint is active or not
	int8_t zeroed;		///< checks to see if the motor is zeroed
}
struct hubo_joint_status {
    // STATx0
    int8_t driverOn;
    int8_t ctrlOn;
    int8_t mode;
    int8_t limitSwitch;
    int8_t homeFlag;

    // STATx1
    int8_t jam;
    int8_t pwmSaturated;
    int8_t bigError;
    int8_t encError;
    int8_t driverFault;
    int8_t motorFail0;
    int8_t motorFail1;
    
    // STATx2
    int8_t posMinError;
    int8_t posMaxError;
    int8_t velError;
    int8_t accError;
    int8_t tempError;
}
struct hubo_jmc_state {
	double temp;	///< temperature (dec C)
	// TODO: Add more things, such as whether an alarm is on
	//	 or whether motor control / FETs are on
}
struct hubo_enc {
    double enc[42];
}
struct hubo_power {
	double voltage;
	double current;
	double power;
}
struct hubo_state {
	hubo_imu imu[3];	///< IMU
	hubo_ft ft[4];   ///< ft sensors
	hubo_joint_state joint[42]; ///> Joint pos, velos, and current
        hubo_joint_status status[42];
	hubo_jmc_state driver[54];
	hubo_power power; // back power board
        double time;
	int16_t refWait;
}
struct hubo_ref {
	double ref[42];	///< joint reference
	int16_t mode[42]; 	///< mode 0 = filter mode, 1 = direct reference mode
	int8_t comply[42];
}

struct hubo_joint_pwm_gains {
    double pwmCommand;
    double Kp;
    double Kd;
    int8_t maxPWM;
}
struct hubo_pwm_gains {
    hubo_joint_pwm_gains joint[42];
}
struct jmcDriver {
    int8_t jmc[5]; // other motors on the same drive
}
